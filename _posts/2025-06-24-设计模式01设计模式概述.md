---
layout: post
title: "设计模式概述"
subtitle: "本博客介绍了代码质量的7个评价标准（可维护性、可扩展性等），阐述了面向对象、设计原则、设计模式、编程规范和重构的编程方法论，重点概述了GoF的23种设计模式及其分类（创建型、结构型、行为型），并强调学习设计模式对提升开发效率的重要性。"
date: 2025-06-24
author: "Hilda"
header-img: "img/post-bg-2015.jpg"
tags:
- 23种设计模式
---

<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_SVG">
</script>





# 1.评价代码质量的7个标准

可以用7个标准评价代码的质量：

**可维护性、可扩展性、可复用性、灵活性、可读性、简洁性、可测试性**

<img src="https://wechat01.oss-cn-hangzhou.aliyuncs.com/img/image-20250624114035442.png" alt="image-20250624114035442" style="zoom:50%;" />

# 2.编程方法论

面向对象、设计原则、设计模式、编程规范、重构

面向对象：是一种编程思想、也是一种编程范式。

设计原则：

- 单一职责原则
- 开闭原则
- 里氏替换原则
- 接口隔离原则
- 依赖倒置原则
- 迪米特原则

设计模式：更多的是解决代码可扩展性问题。设计模式是设计原则具体的实现。

编程规范：主要解决代码可读性问题，更注重代码的细节

> 推荐阅读书籍：
>
> - 代码整洁之道
> - 代码大全
> - 编写可读性代码的艺术

重构：**不改变代码外部行为**的情况下修改代码。你可以改进代码的内部结构、可读性或效率，而用户或外部系统感受到的程序功能保持不变。**重构常常是软件开发循环的一部分**。重构不是一次性的事件，而是集成在日常开发过程中的持续活动。开发者在添加新功能、修复错误或对系统有更深入理解时，经常会进行重构。这是一个迭代的过程，有助于维护代码的健康状态。**持续的重构是保障代码质量不下降的手段**。如果没有重构，代码库可能会变得复杂、难以理解并容易出现错误，这通常被称为“技术债”。持续的重构有助于防止这种质量下降，使代码保持整洁、易于维护，并能适应未来的变化。这是一种积极主动的措施，旨在长期保持高水平的代码质量。

# 3.设计模式概述

【1】什么是设计模式？

设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。世上本没有路，走的人多了，便变成了路。在程序员的世界中，本没有设计模式，写代码是人多了，他们便总结出了一套能提高开发和维护效率的套路，这就是设计模式。

<img src="https://wechat01.oss-cn-hangzhou.aliyuncs.com/img/image-20250624134806749.png" alt="image-20250624134806749" style="zoom:50%;" />

> 书中提及：本书涉及的设计模式并不描述新的或未经证实的设计，我们只收录那些在不同系统中多次使用过的成功设计。

【2】学习设计模式的好处

设计模式是一个程序员的基本功和内力。学习设计模式提高复杂代码的设计和开发能力，有助于我们读懂源码,学习框架更加事半功倍。

【3】设计模式的产生

"设计模式" 最初并不是出现在软件设计中，而是被用于**建筑**领域的设计中。

1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任克里斯托夫·亚历山大（Christopher Alexander）在他的著作《建筑模式语言：城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。

<img src="https://wechat01.oss-cn-hangzhou.aliyuncs.com/img/image-20250624135005010.png" alt="image-20250624135005010" style="zoom:50%;" />

**四人帮（GOF）**：1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。

<img src="https://wechat01.oss-cn-hangzhou.aliyuncs.com/img/image-20250624135103012.png" alt="image-20250624135103012" style="zoom:50%;" />

1994 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。

备注：由于书名太长， 人们将其简称为 "四人组 （Gang of Four， GoF） 的书"， 并且很快进一步简化为 "GoF 的书"。

> 简单介绍下这4个人：
>
> 艾瑞克·伽马（ErichGamma）：瑞士计算机科学家，拥有苏黎世大学计算机科学博士学位。  伽马在软件设计和开发工具领域有重要影响。他不仅是《设计模式》的主要作者之一，还以领导开发Eclipse（一个广泛使用的开源IDE）而闻名。此外，他在Smalltalk编程语言和面向对象设计方面有深入研究。  曾就职于IBM和微软，参与多个软件开发框架和工具的设计。
>
> 理査德·海尔姆（Richard Helm）：澳大利亚计算机科学家，拥有墨尔本大学博士学位。  海尔姆在软件工程和面向对象技术方面有丰富经验。他在《设计模式》中贡献了对模式分类和应用场景的深入分析，尤其在企业级系统设计方面。  曾在IBM工作，专注于分布式系统和软件架构，后进入咨询领域，致力于企业软件解决方案。
>
> 拉尔夫·约翰森（Ralph Johnson）：美国计算机科学家，伊利诺伊大学香槟分校（UIUC）教授，拥有康奈尔大学博士学位。  约翰森在软件架构、框架设计和面向对象编程方面有重要贡献。他在《设计模式》中专注于模式的理论基础和实际应用，尤其在框架开发（如Smalltalk的框架）方面有深入研究。他还是敏捷开发方法（如极限编程）的早期推动者之一。  长期在学术界从事教学与研究，同时指导了许多软件工程领域的项目。
>
> 约翰·威利斯迪斯（John Vlissides）：美国计算机科学家，拥有斯坦福大学博士学位。  威利斯迪斯在《设计模式》中负责模式的结构化描述和可视化表达，他还撰写了多本关于面向对象设计和模式的书籍。他对模式语言（Pattern Language）的概念有深入研究，影响了软件设计领域的发展。  曾在IBM研究中心工作，专注于软件工具和设计方法论。遗憾的是，他于2005年因癌症去世，但他的工作对软件工程领域影响深远。

【4】设计模式的分类

GoF设计模式有23个，它们各具特色，每个模式都为某一个可重复的设计问题提供了一套解决方案。根据它们的用途，设计模式可分为:

- 创建型(Creational)(5种)：提供创建对象的机制，提升已有代码的灵活性和可复用性
    - 常用：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式.
    - 不常用: 原型模式
- 结构型(Structural)(7种)：介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效
    - 常用：代理模式、桥接模式、装饰者模式、适配器模式。
    - 不常用：外观模式、组合模式、享元模式。
- 行为型(Behavioral)(11种)：负责对象间的高效沟通和职责传递委派
    - 常用的有：观察者模式、模板模式、策略模式、责任链模式、迭代器模式、状态模式。
    - 不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。



> **创建型模式（Creational Patterns，5种）**
>
> 1. 单例模式（Singleton）
     >    确保一个类只有一个实例，并提供全局访问点，常用于资源管理。
> 2. 工厂方法模式（Factory Method）
     >    定义一个创建对象的接口，由子类决定实例化哪个类，解耦对象创建与使用。
> 3. 抽象工厂模式（Abstract Factory）
     >    提供一个接口创建一系列相关或依赖的对象族，无需指定具体类。
> 4. 建造者模式（Builder）
     >    将复杂对象的构建过程与其表示分离，支持分步构造和多样化配置。
> 5. 原型模式（Prototype）
     >    通过复制现有对象（原型）来创建新对象，适用于对象创建成本较高的场景。
>
> **结构型模式（Structural Patterns，7种）**
>
> 1. 适配器模式（Adapter）
     >    将不兼容的接口转换为目标接口，使原本不兼容的类能协同工作。
> 2. 桥接模式（Bridge）
     >    将抽象与实现分离，使两者可独立变化，增强系统扩展性。
> 3. 组合模式（Composite）
     >    将对象组织成树形结构，以统一方式处理单个对象和组合对象。
> 4. 装饰者模式（Decorator）
     >    动态为对象添加职责，扩展功能而无需修改原有类。
> 5. 外观模式（Facade）
     >    提供简化的接口，隐藏子系统的复杂性，方便客户端使用。
> 6. 享元模式（Flyweight）
     >    通过共享细粒度对象减少内存占用，适用于大量相似对象的场景。
> 7. 代理模式（Proxy）
     >    通过代理对象控制对另一对象的访问，用于延迟加载或权限控制。
>
> **行为型模式（Behavioral Patterns，11种）**
>
> 1. 责任链模式（Chain of Responsibility）
     >    将请求沿处理者链传递，直到某处理者处理或链结束。
> 2. 命令模式（Command）
     >    将请求封装为对象，支持撤销、重做及操作的解耦。
> 3. 迭代器模式（Iterator）
     >    提供一种方法顺序访问聚合对象的元素，无需暴露其内部结构。
> 4. 中介者模式（Mediator）
     >    通过中介对象协调多个对象间的交互，降低耦合度。
> 5. 备忘录模式（Memento）
     >    在不破坏封装的前提下，捕获并存储对象的状态以便恢复。
> 6. 观察者模式（Observer）
     >    定义对象间一对多的依赖，当被观察者状态变化时通知所有观察者。
> 7. 状态模式（State）
     >    允许对象在内部状态改变时改变其行为，类似状态机的实现。
> 8. 策略模式（Strategy）
     >    定义一系列算法并封装，使它们可互换，客户端可动态选择算法。
> 9. 模板方法模式（Template Method）
     >    定义算法骨架，将特定步骤延迟到子类实现，保持结构一致。
> 10. 访问者模式（Visitor）
      >     将操作与对象结构分离，允许在不修改类的情况下添加新操作。
> 11. 解释器模式（Interpreter）
      >     为特定语言定义语法表示，并提供解释器来处理该语言的句子。

推荐阅读：

- 图解设计模式(结城浩)
- 大话设计模式







